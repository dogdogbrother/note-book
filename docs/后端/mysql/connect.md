## 整俩表用于理解连接

```
CREATE TABLE t1 (m1 int, n1 char(1));

CREATE TABLE t2 (m2 int, n2 char(1));

INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');

INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
```
表的内容如下:
```
mysql> SELECT * FROM t1;
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM t2;
+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
3 rows in set (0.00 sec)
```
**连接**的本质就是讲多个表依次匹配组件返回:
```
mysql> SELECT * FROM t1, t2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    1 | a    |    2 | b    |
|    2 | b    |    2 | b    |
|    3 | c    |    2 | b    |
|    1 | a    |    3 | c    |
|    2 | b    |    3 | c    |
|    3 | c    |    3 | c    |
|    1 | a    |    4 | d    |
|    2 | b    |    4 | d    |
|    3 | c    |    4 | d    |
+------+------+------+------+
9 rows in set (0.00 sec)
```
一共有**3*3=9**行数据,也就是所谓的[笛卡尔积]()

## 连接过程分析

需求是,在这两个表里面,找到`t1.m1 > 1`并且`t1.m1 = t2.m2`并且`t2.n2 < 'd'`:
```
mysql> SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)
```
分析查找过程:

1. 第一个被查询的表是`t1`,也就是驱动表,找到了2条符合`t1.m1 > 1`的数据.
```
+------+------+
| m1   | n1   |
+------+------+
|    2 | b    |
|    3 | c    |
+------+------+
2 rows in set (0.01 sec)
```
2. 2条数据被遍历去查找`t2`表.`t2`也就是被驱动表.

> 后的内连接和外连接/多表连接/自连接等等 有点让人迷惑,暂时不写了.


